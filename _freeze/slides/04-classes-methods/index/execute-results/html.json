{
  "hash": "819fb7130108e7fb898a074fd4476b89",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: Classes and Methods\nsubtitle: R Programming 2025\nauthor: \n  - name: Ella Kaye and Heather Turner\n  - name: Department of Statistics, University of Warwick\ndate: 2025-03-25\ndate-format: long\nfooter: <https://warwick-stats-resources.github.io/r-programming-2025>\nformat: \n  warwickpres-revealjs:\n    execute:\n      echo: true\n      code-overflow: wrap\n---\n\n\n\n\n\n\n## Overview\n\n- Object-oriented programming\n- S3\n- Other OOP systems (S4, R6, S7)\n\n## Source material\n\nThis material is largely based on Chapters 12 and 13 of Advanced R, 2nd edition, by Hadley Wickham.\n\nThe book is freely available online: <https://adv-r.hadley.nz>.\n\nIt is shared under the [Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License](https://creativecommons.org/licenses/by-nc-sa/4.0/).\n\n# Object-oriented programming {.inverse}\n\n## Object-oriented programming (OOP)\n\nWith OOP, a developer can consider a function's interface separately from its implementation. \n\nThis makes it possible to use the same function for different types of input. \n\nThese are called **generic** functions. \n\n## OOP definitions\n\n- OO systems call the type of an object its **class**.\n\n- An implementation for a specific class is called a **method**.\n\n- The class defines the **fields**, the data possessed by every instance of that class.\n\n. . .\n\n:::{.callout-tip}\nRoughly speaking, a class defines what an object *is* and methods define what an object can *do*.\n:::\n\n## OOP definitions (continued)\n\n- Classes are organised in a hierarchy, so that if a method does not exist for one class, its parent's method is used.\n\n- The child is said to **inherit** behaviour.\n\n- The process of finding the correct method given a class is called **method dispatch**.\n\n## Generic functions\n\n**Generic** functions provide a unified interface to **methods** for objects of a particular **class**, e.g.\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nlibrary(palmerpenguins)\n```\n:::\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nsummary(penguins$species)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   Adelie Chinstrap    Gentoo \n      152        68       124 \n```\n\n\n:::\n\n```{.r .cell-code}\nsummary(penguins$flipper_length_mm)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max.    NA's \n    172     190     197     201     213     231       2 \n```\n\n\n:::\n:::\n\n\n\nHere, we use the same function, `summary()`, on objects of classes `factor` and `integer` and get different output for each.\n\n## Motivation for OOP\n\n`summary()` could contain several if-else statements, but \n\n- the code would become hard to follow\n- only the function authors (R Core) could add new implementations\n\n## What does OOP offer?\n\n- separates the code for different data types\n- avoids duplicating code by method inheritance from parent class(es) to child class (subclass)\n- makes it possible for external developers to add methods for new types of object\n  - this can be particularly useful when writing R packages\n\n\n## OOP Systems in R\n\nThere are 3 main OOP systems in use:\n\n:::{.smaller90}\n* **S3** \n  - Used in base R and most recommended/CRAN packages\n  - Use unless you have good reason not to\n* **S4**\n  - Used on Bioconductor\n  - Allow more complex relationships between classes and methods\n* **R6**\n  - More similar to OOP in other languages\n  - May prefer if S3 insufficient and not aiming for Bioconductor\n    \nA new OOP system, **S7**, is in [development](https://rconsortium.github.io/S7/) as a successor to **S3** and **S4**. \n:::\n\n:::{.notes}\nR6 v similar to Python OOP (also Java, C++)\nJulia not an OOP language, but does have concept of multiple dispatch\n- so maybe a bit more like S3 idea?\n:::\n\n## sloop\n\nThe **sloop** package provides tools to help you interactively explore and understand object oriented programming in R, particularly with S3.\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nlibrary(sloop)\n```\n:::\n\n\n\n## Objects\n\nIn R, we can distinguish between **base objects** and **OO objects**.\n\nA base object:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nis.object(1:10)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE\n```\n\n\n:::\n\n```{.r .cell-code}\nsloop::otype(1:10)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"base\"\n```\n\n\n:::\n:::\n\n\n\nAn OO object:\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nis.object(penguins)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\nsloop::otype(penguins)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"S3\"\n```\n\n\n:::\n:::\n\n\n\n\n::: {.notes}\nEverything in R is an object, but not everything is object-oriented.  \n:::\n\n## Classes\n\nTechincally, the difference between base and OO objects is that OO objects have a **class** attribute:\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nattr(1:10, \"class\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nNULL\n```\n\n\n:::\n\n```{.r .cell-code}\nattr(penguins, \"class\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"tbl_df\"     \"tbl\"        \"data.frame\"\n```\n\n\n:::\n\n```{.r .cell-code}\nsloop::s3_class(penguins)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"tbl_df\"     \"tbl\"        \"data.frame\"\n```\n\n\n:::\n:::\n\n\n\n## Base types\n\nOnly OO objects have a class attribute, but every object has a **base type**.\n\nThere are 25 different base types, e.g.\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ntypeof(NULL)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"NULL\"\n```\n\n\n:::\n\n```{.r .cell-code}\ntypeof(1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"double\"\n```\n\n\n:::\n\n```{.r .cell-code}\ntypeof(1L)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"integer\"\n```\n\n\n:::\n\n```{.r .cell-code}\ntypeof(\"hello\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"character\"\n```\n\n\n:::\n:::\n\n\n## \"object of type 'closure' is not subsettable\"\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ntypeof(mean)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"closure\"\n```\n\n\n:::\n\n```{.r .cell-code}\nmean[1]\n```\n\n::: {.cell-output .cell-output-error}\n\n```\nError in mean[1]: object of type 'closure' is not subsettable\n```\n\n\n:::\n:::\n\n\n\n. . . \n\nJenny Bryan's talk on debugging: \n\n<https://posit.co/resources/videos/object-of-type-closure-is-not-subsettable/>\n\n# S3 {.inverse}\n\n## S3 objects\n\nAn S3 object has a `\"class\"` attribute:\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nattr(penguins$species, \"class\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"factor\"\n```\n\n\n:::\n\n```{.r .cell-code}\nunique(penguins$species)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] Adelie    Gentoo    Chinstrap\nLevels: Adelie Chinstrap Gentoo\n```\n\n\n:::\n:::\n\n\n\n## S3 objects: the underlying object\n\nWith `unclass()` we obtain the underlying object, its **base type**, here an integer vector \n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nspecies_no_class <- unclass(penguins$species)\nclass(species_no_class)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"integer\"\n```\n\n\n:::\n\n```{.r .cell-code}\nunique(species_no_class)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1 3 2\n```\n\n\n:::\n\n```{.r .cell-code}\nattributes(species_no_class)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$levels\n[1] \"Adelie\"    \"Chinstrap\" \"Gentoo\"   \n```\n\n\n:::\n:::\n\n\n## OO type vs base type when passed to generic\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nf <- factor(c(\"a\", \"b\", \"c\"))\nprint(f)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] a b c\nLevels: a b c\n```\n\n\n:::\n\n```{.r .cell-code}\nprint(unclass(f))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1 2 3\nattr(,\"levels\")\n[1] \"a\" \"b\" \"c\"\n```\n\n\n:::\n:::\n\n\n\n## generic as middleman\n\n> The generic is the middleman: its job is to define the interface (i.e. the arguments) then find the right implementation for the job. The implementation for a specific class is called a **method**, and the generic finds that method by performing **method dispatch**.\n\nHadley Wickham, Advanced R (2e)\n\n## Naming scheme\n\nS3 methods are functions with a special naming scheme, `generic.class()`. For example, the `factor` method for the `print()` generic is called `print.factor()`.\n\nYou should never call the method directly, but instead rely on the generic to find it for you.\n\n. . . \n\n:::{.callout-tip}\nThis is why it is not considered best practice to use `.` when naming your own functions.\n:::\n\n. . .\n\n:::{.callout-warning}\nLots of important R functions that are **not** methods *do* have `.` in the title -- these are from before S3.\n:::\n\n::: {.notes}\ne.g.\ndata.frame()\nrow.names()\n:::\n\n## Creating OO objects\n\nTo make an object an instance of a class, you simply set the **class attribute**.\n\n(S3 has no formal definition of a class).\n\n## Creating an S3 object with `stucture()`\n\nYou can use `structure()` to define an S3 object with a class attribute:\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ndp <- 2\nstructure(list(pi = trunc(10^dp * pi)/10^dp, dp = dp),\n          class = \"pi_trunc\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$pi\n[1] 3.14\n\n$dp\n[1] 2\n\nattr(,\"class\")\n[1] \"pi_trunc\"\n```\n\n\n:::\n:::\n\n\n\nPotentially further attributes can be added at the same time, but typically we would use a list to return all the required values.\n\n## Creating an S3 object with `class()`\n\nAlternatively, we can add a class attribute using the `class()` helper function:\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\npi2dp <- list(pi = trunc(10^dp * pi)/10^dp, dp = dp)\nclass(pi2dp) <- \"pi_trunc\"\npi2dp\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$pi\n[1] 3.14\n\n$dp\n[1] 2\n\nattr(,\"class\")\n[1] \"pi_trunc\"\n```\n\n\n:::\n:::\n\n\n\n\n## Creating your own classes\n\nAll objects of the same class should have the same structure, i.e. same base type and same attributes.\n\nRecommend that you create:\n\n- a low-level **constructor**, `new_myclass()`, that efficiently creates objects with the correct structure\n- A **validator**, `validate_myclass()` that performs more computationally expensive checks to ensure the object has correct values\n- A user-friendly **helper**, `myclass()`, that provides a convenient way for others to create objects of your class.\n\nSee <https://adv-r.hadley.nz/s3.html#s3-classes> for more details.\n\n## print generic\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nprint(pi2dp)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$pi\n[1] 3.14\n\n$dp\n[1] 2\n\nattr(,\"class\")\n[1] \"pi_trunc\"\n```\n\n\n:::\n:::\n\n\n\n:::{.notes}\nSee what happens before we define a custom print method later\n\nPrints like a list along with the attribute\n:::\n\n## S3 generic functions\n\nS3 generic functions are simple wrappers to `UseMethod()`\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nprint\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nfunction (x, ...) \nUseMethod(\"print\")\n<bytecode: 0x12abe8328>\n<environment: namespace:base>\n```\n\n\n:::\n:::\n\n\n\n## `useMethod()`\n\nThe `UseMethod()` function takes care of *method dispatch*: selecting the S3 method according to the class of the object passed as the first argument.\n\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nclass(penguins$species[1:3])\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"factor\"\n```\n\n\n:::\n\n```{.r .cell-code}\nprint(penguins$species[1:3])\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] Adelie Adelie Adelie\nLevels: Adelie Chinstrap Gentoo\n```\n\n\n:::\n:::\n\n\n\nHere `print()` dispatches to the method `print.factor()`. \n\n## `s3_dispatch()`\n\n`UseMethod()` creates a vector of method names then looks for each potential method in turn. We can see this with `sloop::s3_dispatch()`:\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ns3_dispatch(print(penguins$species))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n=> print.factor\n * print.default\n```\n\n\n:::\n:::\n\n\n\n- `=>` indicates the method that is called here.\n- `*` indicated a method that is defined, but not called.\n\n## `default`\n\n`default` is a special **pseudo-class** that provides a fallback whenever a class-specific method is not available.\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ns3_dispatch(print(pi2dp))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   print.pi_trunc\n=> print.default\n```\n\n\n:::\n:::\n\n\n\n`print.pi_trunc` is not defined.\n\n## Method dispatch\n\nAn S3 object can have more than one class e.g.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nclass(penguins)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"tbl_df\"     \"tbl\"        \"data.frame\"\n```\n\n\n:::\n:::\n\n\n`UseMethod()` works along the vector of classes (from the first class to the last), looks for a method for each class and dispatches to the first method it finds.\n\nIf no methods are defined for any of class, the default is used , e.g. `print.default()`.\n\nIf there is no default, an error is thrown.\n\n## S3 methods for a class\n\nSee the methods for a given S3 class:\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n# nls is nonlinear least squares\nmethods(class = \"nls\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] anova       coef        confint     deviance    df.residual fitted     \n [7] formula     logLik      nobs        predict     print       profile    \n[13] residuals   summary     vcov        weights    \nsee '?methods' for accessing help and source code\n```\n\n\n:::\n:::\n\n\n. . . \n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ns3_methods_class(\"nls\") |> head()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 6 × 4\n  generic     class visible source             \n  <chr>       <chr> <lgl>   <chr>              \n1 anova       nls   FALSE   registered S3method\n2 coef        nls   FALSE   registered S3method\n3 confint     nls   FALSE   registered S3method\n4 deviance    nls   FALSE   registered S3method\n5 df.residual nls   FALSE   registered S3method\n6 fitted      nls   FALSE   registered S3method\n```\n\n\n:::\n:::\n\n\n\n## S3 methods for a generic\n\nSee the methods for a given generic function:\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nmethods(\"coef\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] coef.aov*     coef.Arima*   coef.default* coef.listof*  coef.maov*   \n[6] coef.nls*    \nsee '?methods' for accessing help and source code\n```\n\n\n:::\n:::\n\n\nAsterisked methods are not exported.\n\n. . .\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ns3_methods_generic(\"coef\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 6 × 4\n  generic class   visible source             \n  <chr>   <chr>   <lgl>   <chr>              \n1 coef    aov     FALSE   registered S3method\n2 coef    Arima   FALSE   registered S3method\n3 coef    default FALSE   registered S3method\n4 coef    listof  FALSE   registered S3method\n5 coef    maov    FALSE   registered S3method\n6 coef    nls     FALSE   registered S3method\n```\n\n\n:::\n:::\n\n\n\n## View S3 methods\n\nS3 methods need not be in the same package as the generic.\n\nFind an unexported method with `getS3method()` or `sloop::s3_get_method()`\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ngetS3method(\"coef\", \"default\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nfunction (object, complete = TRUE, ...) \n{\n    cf <- object$coefficients\n    if (complete) \n        cf\n    else cf[!is.na(cf)]\n}\n<bytecode: 0x1181054d8>\n<environment: namespace:stats>\n```\n\n\n:::\n:::\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ns3_get_method(\"coef.default\") # equivalent\n```\n:::\n\n\n\n\n::: {.notes}\nCan view code for exported functions by just typing the function name, or, in RStudio, using `View(function_name)`  \n:::\n\n## Writing S3 Methods\n\nThe arguments of a new method should be a superset of the arguments of the generic\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nargs(print)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nfunction (x, ...) \nNULL\n```\n\n\n:::\n:::\n\n\n\n. . .\n\nNew methods have the name format `generic.class`:\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nprint.pi_trunc <- function(x, abbreviate = TRUE, ...){\n  dp_text <- ifelse(abbreviate, \"d.p.\", \"decimal places\")\n  cat(\"pi: \", x$pi, \" (\", x$dp, \" \", dp_text, \")\", sep = \"\")\n}\nprint(pi2dp)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\npi: 3.14 (2 d.p.)\n```\n\n\n:::\n:::\n\n\n\n. . . \n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nprint(pi2dp, abbreviate = FALSE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\npi: 3.14 (2 decimal places)\n```\n\n\n:::\n:::\n\n\n\n::: {.notes}\nNote the difference compared to calling `print(pi2dp)` before.\n:::\n\n## Inheritance\n\nS3 classes can share behaviour through a mechanism called **inheritance**. Inheritance is powered by three ideas.\n\n- The class can be a character *vector*\n\n- If a method is not found for the class in the first element of the vector, R looks for a method in the second class (and so on)\n\n- A method can delegate work by calling `NextMethod()`.\n\n## Multiple classes\n\nThe class of an S3 object can be a vector of classes: \n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nfit <- glm(y ~ x, data = data.frame(y = 1:3, x = 4:6))\nclass(fit)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"glm\" \"lm\" \n```\n\n\n:::\n:::\n\n\nWe say `fit` is a `\"glm\"` object that **inherits** from class `\"lm\"`.\n\n- `glm` is a **subclass** of `lm`, because it always appears before it in the class vector.\n\n- `lm` is a **superclass** of `glm`.\n\n::: {.notes}\nGood practice:\n\n- base type of the subclass should be the same as the superclass\n\n- attributes of the subclass should be a superset of the attributes of the superclass.\n\nThese practices are not enforced. These are recommendations in Advanced R for make life easier.  \n:::\n\n## `inherits()`\n\nThe `inherits()` function can be used to test if an object inherits from a given class:\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ninherits(fit, \"glm\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\ninherits(fit, \"lm\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\ninherits(fit, \"xlm\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE\n```\n\n\n:::\n:::\n\n\n\n\n## Your turn (part 1)\n\n\n\n::: {.cell layout-align=\"center\"}\n\n:::\n\n\n\n1. Create a function to fit an ordinary least squares model (using `lm()`) given a response `y` and an explanatory variable `x`, that returns an object of a new class `\"ols\"`, that inherits from `\"lm\"`.\n\n2. Define a print method for your function that it works as follows:\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nset.seed(1)\nres <- ols(x = 1:3, y = rnorm(3))\nres\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nIntercept:  -0.217 \nSlope:  -0.1046 \n```\n\n\n:::\n:::\n\n\n\nNote: I have set `options(digits = 4)` to limit the number of digits printed by default throughout this presentation (default is 7).\n\n\n## `NextMethod()`\n\nHard to understand, so here's a concrete example for the common use case: `[`.\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nnew_secret <- function(x = double()) {\n  stopifnot(is.double(x))\n  structure(x, class = \"secret\")\n}\n\nprint.secret <- function(x, ...) {\n  print(strrep(\"x\", nchar(x)))\n  invisible(x)\n}\n\nx <- new_secret(c(15, 1, 456))\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"xx\"  \"x\"   \"xxx\"\n```\n\n\n:::\n:::\n\n\n\n::: {.notes}\n?`[`\n:::\n\n## But there's a problem\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nx[1]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 15\n```\n\n\n:::\n:::\n\n\n\nWe want this to be secret!\n. . . \n\nThe default `[` method doesn't preserve the class.\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ns3_dispatch(x[1])\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   [.secret\n   [.default\n=> [ (internal)\n```\n\n\n:::\n:::\n\n\n\n::: {.notes}\nThere's no `[.default` defined (no `*` next to it), just an internal generic. We'll learn more about those later.  \n:::\n\n## A first attempt at a solution\n\nSo, need to defined a `[.secret` method. \n\nBut the following doesn't work:\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n`[.secret` <- function(x, i) {\n  new_secret(x[i])\n}\nx[1]\n```\n:::\n\n\n\nIt gets stuck in infinite loop.\n\n\n::: {.notes}\nTrying to subset `x` then call new_secret on it, to give it the `secret` class, so that `print.secret` works on said subset.  \n\nBut get infinite loop because using `[` in definition\n:::\n\n## What's the fix?\n\nWe need some way of calling the underlying `[` code, i.e. the implementation that would get called if we didn't have a `[.secret` method.\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n`[.secret` <- function(x, i) {\n  new_secret(NextMethod())\n}\nx[1]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"xx\"\n```\n\n\n:::\n:::\n\n\n\n. . . \n\ni.e. we're defining `[.secret` but we still want to access the internal `[` method (so we don't get stuck in a loop) as if `[.secret` wasn't defined.\n\n\n## Delegation with `NextMethod()`\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ns3_dispatch(x[1])\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n=> [.secret\n   [.default\n-> [ (internal)\n```\n\n\n:::\n:::\n\n\n\nThe `=>` indicates that `[.secret` is called, but that `NextMethod()` delegates work to the underlying internal `[` method, as shown by `->`.\n\n## Another `NextMethod()` example\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ndata <- data.frame(x = 1:3, y = 4:6)\nclass(data)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"data.frame\"\n```\n\n\n:::\n\n```{.r .cell-code}\ndata\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  x y\n1 1 4\n2 2 5\n3 3 6\n```\n\n\n:::\n\n```{.r .cell-code}\nt(data)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  [,1] [,2] [,3]\nx    1    2    3\ny    4    5    6\n```\n\n\n:::\n:::\n\n\n\n::: {.notes}\n`t()` is the transpose function. \nWe started with a data.frame but after calling `t` on it, we have a matrix. What happened?\n:::\n\n## Underlying code\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nt.data.frame\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nfunction (x) \n{\n    x <- as.matrix(x)\n    NextMethod(\"t\")\n}\n<bytecode: 0x10a2dfbc0>\n<environment: namespace:base>\n```\n\n\n:::\n:::\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ns3_dispatch(t(data))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n=> t.data.frame\n-> t.default\n```\n\n\n:::\n:::\n\n\n\n. . .\n\nWe can explicitly call the next method that would be called by `UseMethod()` to reuse code whilst customising as required.\n\n:::{.notes}\nWe have seen that `UseMethod()` will dispatch to the method of the next class in the class vector if a method is not defined for the first class.\n:::\n\n## Your turn (part 2)\n\n\n\n::: {.cell layout-align=\"center\"}\n\n:::\n\n\n\n3. Write a summary method for your `ols` class that uses `NextMethod()` to compute the usual `lm` summary, but return an object of class `\"summary.ols\"`. \n\n4. Write a print method for the `\"summary.ols\"` which works as follows:\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nsummary(res)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nCoefficients: \n            Estimate Std. Error t value Pr(>|t|)\n(Intercept)  -0.2170     1.1408 -0.1902   0.8804\nx            -0.1046     0.5281 -0.1980   0.8755\n\nResidual standard error:  0.7468 \nMultiple R-squared:  0.03774 \n```\n\n\n:::\n:::\n\n\n\n:::{.notes}\nwill get issues with inheriting e.g. add1 method\n:::\n\n# Other OOP systems {.inverse}\n\n## S4\n\nS4 provides a formal approach to OOP. Its implementation is much stricter than S3.\n\nS4 has **slots**, a named component of the object accessed with `@`.\n\nS4 methods:\n\n- use specialised functions for creating classes, generics and methods\n- allow _multiple inheritance_: a class can have multiple parents\n- allow _multiple dispatch_: method selection based on the class of multiple objects\n\n:::{.notes}\nuse import instead\n\nThe **methods** package provides the functions required to use S4 classes and methods, so always load this package when using S4.\n:::\n\n## S4 uses\n\n- S4 is the OOP system used for bioconductor packages\n- The **Matrix** package\n\n## R6\n\n- The R6 OOP system is defined in the **R6** package: <https://r6.r-lib.org>\n- Encapsulated OOP, similar to OOP systems in other languages\n- The Advanced R book cautions against using R6 - it leads to non-idiomatic R code.\n\n## S7\n\n- Currently in the **S7** package: <https://rconsortium.github.io/S7/>\n- Will eventually be incorporated into R as the successor S3 and S4. \n- An example of using S7 for generative art: <https://blog.djnavarro.net/posts/2024-02-25_s7/>\n\n# End matter {.inverse}\n\n## References\n\n- Main reference for this session, goes a bit further (including R6):\nWickham, H, _Advanced R_ (2nd edn), _Object-oriented programming section_, <https://adv-r.hadley.nz/oo.html>\n\n- Fun example creating `Turtle` and `TurtleWithPen` classes to create simple graphics by moving the turtle:\n<https://stuartlee.org/2019/07/09/s4-short-guide/> \n\n## License\n\nLicensed under a Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License ([CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/){target=\"_blank\"}).\n\n# Extra slides {.inverse}\n\n## Implicit classes\n\nAs we've seen, `is.object()` or `sloop::otype()` can be used to find out if an object has a class (S3/S4/R6)\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nis.object(factor(1:3))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n\n```{.r .cell-code}\nis.object(1:3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] FALSE\n```\n\n\n:::\n:::\n\n\n\nAn object that does not have an explicit class has an implicit class that will be used for S3 method dispatch. \n\n## Implicit classes and dispatch\n\nThe implicit class can be found with `.class2()`, or `sloop::s3_class()`\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nM <- matrix(1:12, nrow = 4)\nattr(M, \"class\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nNULL\n```\n\n\n:::\n\n```{.r .cell-code}\n.class2(M)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"matrix\"  \"array\"   \"integer\" \"numeric\"\n```\n\n\n:::\n\n```{.r .cell-code}\ns3_class(M)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"matrix\"  \"integer\" \"numeric\"\n```\n\n\n:::\n:::\n\n\n\nThe `class()` of an object does not uniquely determine its dispatch:\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ns3_dispatch(print(M))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   print.matrix\n   print.integer\n   print.numeric\n=> print.default\n```\n\n\n:::\n:::\n\n\n\n:::{.notes}\n.class2 since R 4.0.0. \n:::\n\n## Attributes\n:::{.smaller90}\nWe can take advantage of existing S3 methods by returning an object of a existing S3 class or an implicit class, using attributes to add custom information\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nx <- matrix(c(1:5, 2*(1:5)), ncol = 2)\ncenter_x <- scale(x, scale = FALSE)\nclass(center_x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"matrix\" \"array\" \n```\n\n\n:::\n\n```{.r .cell-code}\nsummary(center_x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n       V1           V2    \n Min.   :-2   Min.   :-4  \n 1st Qu.:-1   1st Qu.:-2  \n Median : 0   Median : 0  \n Mean   : 0   Mean   : 0  \n 3rd Qu.: 1   3rd Qu.: 2  \n Max.   : 2   Max.   : 4  \n```\n\n\n:::\n:::\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nattr(center_x, \"scaled:center\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3 6\n```\n\n\n:::\n:::\n\n\nThis can avoid the need to define new classes and methods, in simple cases.\n:::\n\n::: {.notes}\n`attr(x, \"scaled:center\")` in `NULL`\n\n`center_x` is still a matrix, and so `summary(center_x)` dispatches to `summary.matrix`. We can take advantage of the methods for `matrix`, without needing to define a new class for `scaled`.\n:::\n\n## Under the hood\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ns3_dispatch(scale(x, scale = FALSE))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   scale.matrix\n   scale.double\n   scale.numeric\n=> scale.default\n```\n\n\n:::\n:::\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ns3_dispatch(summary(center_x))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n=> summary.matrix\n   summary.double\n   summary.numeric\n * summary.default\n```\n\n\n:::\n:::\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nView(scale.default)\n```\n:::\n\n\n\n. . .\n\nIn `scale.default()` the attribute `\"scaled:center\"` is added to the `x` argument, so essentially, `center_x` is a matrix with extra information (in this case, the colMeans of the original columns).\n\n## Warning!\n\nS3 has no checks for correctness, so we can change the class of objects. \n\n**This is a bad idea!**\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nmod <- lm(flipper_length_mm ~ bill_length_mm, data = penguins)\nclass(mod)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"lm\"\n```\n\n\n:::\n\n```{.r .cell-code}\nclass(mod) <- \"Date\"\nprint(mod)\n```\n\n::: {.cell-output .cell-output-error}\n\n```\nError in as.POSIXlt(.Internal(Date2POSIXlt(x, tz)), tz = tz): 'list' object cannot be coerced to type 'double'\n```\n\n\n:::\n:::\n\n\n\n. . .\n\n> R doesn't stop you from shooting yourself in the foot, but as long as you don't aim the gun at your toes and pull the trigger, you won't have a problem.",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-after-body": [
        "\n<script>\n  // htmlwidgets need to know to resize themselves when slides are shown/hidden.\n  // Fire the \"slideenter\" event (handled by htmlwidgets.js) when the current\n  // slide changes (different for each slide format).\n  (function () {\n    // dispatch for htmlwidgets\n    function fireSlideEnter() {\n      const event = window.document.createEvent(\"Event\");\n      event.initEvent(\"slideenter\", true, true);\n      window.document.dispatchEvent(event);\n    }\n\n    function fireSlideChanged(previousSlide, currentSlide) {\n      fireSlideEnter();\n\n      // dispatch for shiny\n      if (window.jQuery) {\n        if (previousSlide) {\n          window.jQuery(previousSlide).trigger(\"hidden\");\n        }\n        if (currentSlide) {\n          window.jQuery(currentSlide).trigger(\"shown\");\n        }\n      }\n    }\n\n    // hookup for slidy\n    if (window.w3c_slidy) {\n      window.w3c_slidy.add_observer(function (slide_num) {\n        // slide_num starts at position 1\n        fireSlideChanged(null, w3c_slidy.slides[slide_num - 1]);\n      });\n    }\n\n  })();\n</script>\n\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}